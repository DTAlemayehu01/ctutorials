#+title: Graph

* Table of Contents :toc:
- [[#graph-properties][Graph Properties]]
- [[#graph-declarations][Graph Declarations]]
- [[#graph-definitions][Graph Definitions]]
  - [[#struct-edge][struct Edge]]
  - [[#struct-vertex][struct Vertex]]
  - [[#class-graph][class Graph]]

* Graph Properties
You know those internconnectivity webs? Those as esentially what graphs are.

A graph has 2 primary properties.
1. Is the graph directed or undirected? In other words, for all nodes, if there is an edge, can it be traversed both ways?
2. Is the graph weighted or unweighted? In other words, are all edges equal, or are the numeric values representing the preference to traversing that edge over another edge?

Real Life Examples:
Google Maps
* Graph Declarations
Here is the declaration for a graph, that supports all different types of graphs.
#+NAME: Graph Declaration
#+begin_src cpp :exports code :noweb strip-export :tangle graph.hpp
#ifndef GRAPH_H_
#define GRAPH_H_
#include<string>
#include<stack>
#include<queue>

struct Edge {
    vertex * v;
    int weight;
};

struct Vertex {
    <<type>> key;
    int distance = 0;
    bool visited = false;
    vector<edge> adj;
    vertex *previous = nullptr;
};

class Graph {
    private:
        vector<vertex*> verticies;
    public:
        Graph();
        ~Graph();
        void insertVertex(<<type>> key);
        void addEdge(<<type>> startValue, <<type>> endValue);
        void addEdge(<<type>> startValue, <<type>> endValue, int weight);
        void deleteVertex(<<type>> value);
        void deleteEdge(<<type>> startValue, <<type>> endValue);
        void displayGraph();
        void search(<<type>> value); //?
        void BFT(<<type>> keyStart);
        void BFS(<<type>> keyStart, <<type>> searchKey);
        void DFTStack(<<type>> keyStart);
        void DFTRecusriveHelper(<<type>> keyStart);
        void DFTRecusrive(<<type>> keyStart);
        void dijkstraTraversal(<<type>> keyStart, <<type>> searchKey);
};
#+end_src
* Graph Definitions
** struct Edge
- ~vertex * v~ -> a pointer to a ~Vertex~ in the ~Graph~
- ~int weight~ -> the weight of the ~edge~, mandatory for /weighted/ graphs
** struct Vertex
- ~<<type>> key~ -> data of a nonspecific type, what is supposed to be stored in a ~Vertex~ of the ~Graph~
- ~int distance~ -> stores the distance from the starting ~Vertex~ in traversal algorithms, default of ~0~
- ~bool visited~ -> stores if a vertex has been visited/solved during traversal algorithms, default of ~false~
- ~vector<edge> adj~ -> stores the adjacency list of verticies the ~Vertex~ is connected to through the ~vector~ of ~edge~ structs
- ~vertex * previous~ -> stores the previous ~vertex~ traversed during traversal algorithms, optional but useful if trying to note paths during traversal
** class Graph
*** private
- ~vector<vertex*> verticies~ -> stores all ~verticies~ in the ~Graph~
*** public
- ~Graph()~ -> class constructor
- ~~Graph()~ -> class deconstructor
- ~void insertVertex(<<type>> key)~ -> inserts a new ~vertex~ in the graph storing the data of a nonspecific type in the ~vertex~
#+NAME: Insert Vertex
#+begin_src cpp :exports both :noweb strip-export
void Graph::addVertex(<<type>> key) {
    int size = verticies.size();
    for(int i = 0; i < size; i++) {
        if(verticies[i]->key == key) {
            return;
        }
    }
    vertex *newVertex = new vertex;
    newVertex->key = key;
    verticies.push_back(newVertex);
}
#+end_src
- ~void addEdge(<<type>> startValue, <<type>> endValue)~ -> inserts an unweighted ~Edge~ directed from the ~vertex~ storing ~startValue~ to the ~vertex~ storing ~endValue~. Can call the function ~addEdge(endValue, startValue)~ in the function to make it an undirected edge.
#+NAME: Add Unweighted Edge
#+begin_src cpp :exports both :noweb strip-export
void Graph::addEdge(<<type>> startValue, <<type>> endValue) {
    vertex* start = nullptr;
    vertex* end = nullptr;
    int size = verticies.size();
    for(int i = 0; i < size; i++){
        if(verticies[i]->key == startValue) {
            start = verticies[i];
        }
        if(verticies[i]->key == endValue) {
            end = verticies[i];
        }
    }
    if(!start || !end) {
        return;
    }
    if(start == end) {
        return;
    }
    Edge startToEnd;
    startToEnd.v = end;
    start->adj.push_back(startToEnd);
}
#+end_src
- ~void addEdge(<<type>> startValue, <<type>> endValue, int weight)~ -> inserts an weighted ~Edge~ of ~int weight~ directed from the ~vertex~ storing ~startValue~ to the ~vertex~ storing ~endValue~.
#+NAME: Add Weighted Edge
#+begin_src cpp :exports both :noweb strip-export
void Graph::addEdge(<<type>> startValue, <<type>> endValue, int weight) {
    vertex* start = nullptr;
    vertex* end = nullptr;
    int size = verticies.size();
    for(int i = 0; i < size; i++){
        if(verticies[i]->key == startValue) {
            start = verticies[i];
        }
        if(verticies[i]->key == endValue) {
            end = verticies[i];
        }
    }
    if(!start || !end) {
        return;
    }
    if(start == end) {
        return;
    }
    Edge startToEnd;
    startToEnd.v = end;
    startToEnd.weight = weight;
    start->adj.push_back(startToEnd);
}
#+end_src
- ~void deleteVertex(<<type>> value)~ -> deletes the ~vertex~ storing ~value~ from the ~Graph~ (make sure all edges are deleted)
- ~void deleteEdge(<<type>> startValue, <<type>> endValue)~ -> deletes the ~Edge~ directed from the ~vertex~ storing ~startValue~ from the ~Vertex~ storing ~endValue~
- ~void displayGraph()~ -> displays the ~Graph~ in output, our implementation outputs the ~key~ of each ~vertex~ and the ~key~ of each ~Edge~ connected to the ~vertex~ on the same line.
#+NAME: Display Graph
#+begin_src cpp :exports both: noweb strip-export
void Graph::displayGraph(){
    int sizeVs = verticies.size();
    int size = 0;
    for(int i = 0; i < sizeVs; i++){
        std::cout << verticies[i]->key << " ";
        size = verticies[i]->adj.size();
        for(int j = 0; j < size; j++) {
            std::cout << verticies[i]->adj[j].v->key << " ";
        }
        std::cout << std:endl;
    }
}
#+end_src
- ~void BFT(<<type>> keyStart)~ -> generic BFT starting from the ~Vertex~ storing ~keyStart~
#+NAME: BFT
#+begin_src cpp :exports code :noweb strip-export
void Graph::BFT(<<type>> keyStart){
    vertex* vStart;
    vertex* pop;
    int size = verticies.size();

    for(int i = 0; i < size; i++){
        verticies[i]->visited = false;
        verticies[i]->distance = 0;
    }

    for(int i = 0; i < size; i++) {
        if(verticies[i]->key == keyStart) {
            vStart = verticies[i];
            break;
        }
    }

    queue<vertex*> Q;
    Q.push(vStart);

    vStart->visited = true;

    while(Q.size()) {
        pop = Q.front();
        Q.pop();
        if(!pop->visited) {
            pop->visited = true;
        }
        size = pop->adj.size();
        for(int i = 0; i < size; i++) {
            if(!pop->adj[i].v->visited) {
                Q.push(pop->adj[i].v);
                pop->adj[i].v->previous = pop;
                pop->adj[i].v->distance = pop->distance+1;
            }
        }
    }
}
#+end_src
- ~void BFS(<<type>> keystart, <<type>> searchKey)~ -> BFS algorithm for /unweighted/ ~Graphs~ starting from the ~vertex~ storing ~keyStart~ to the shortest distance to ~searchKey~, for weighted graphs see ~dijkstraTraversal()~
#+NAME: BFS
#+begin_src cpp :exports code :noweb strip-export
void Graph::BFS(<<type>> keyStart, <<type>> searchKey){
    vertex* vStart;
    vertex* vDest;
    vertex* pop;
    int size = verticies.size();

    for(int i = 0; i < size; i++){
        verticies[i]->visited = false;
        verticies[i]->distance = 0;
    }

    for(int i = 0; i < size; i++) {
        if(verticies[i]->key == keyStart) {
            vStart = verticies[i];
        }
        if(verticies[i]->key == searchKey) {
            vDest = verticies[i];
        }
    }

    queue<vertex*> Q;
    Q.push(vStart);

    vStart->visited = true;

    while(Q.size()) {
        pop = Q.front();
        Q.pop();
        if(!pop->visited) {
            pop->visited = true;
        }
        size = pop->adj.size();
        for(int i = 0; i < size; i++) {
            if(!pop->adj[i].v->visited) {
                Q.push(pop->adj[i].v);
                pop->adj[i].v->previous = pop;
                pop->adj[i].v->distance = pop->distance+1;
            }
        }
        if(pop == vDest){
            break;
        }
    }
    if(!vDest->visited){
        std::cout << "No path from start to end" << std::endl;
    }

    vertex* crawler = pop;
    while(crawler) {
        crawler = crawler->previous;
    }
}
#+end_src
- ~void DFTStack(<<type>> keyStart)~ -> DFT algorithm starting from ~vertex~ storing ~keyStart~, implemented utilizing ~Stack~ data strucuture.
- ~void DFTRecursiveHelper(<<type>> keyStart)~ and ~void DFTRecursive(<<type>> keyStart) -> same as ~DFTStack()~ but utilizing recursion
- ~void dijkstraTraversal(<<type>> keyStart, <<type>> searchKey)~ -> Dijkstra's graph traversal for /weighted/ ~Graphs~.
#+NAME: dijsktraTraversal
#+begin_src cpp :exports code :noweb strip-export
void Graph::dijsktraTraversal(<<type>> keyStart, <<type>> searchKey){
    vertex* vStart;
    vertex* vDest;
    vertex* pop;
    int size = verticies.size();

    for(int i = 0; i < size; i++){
        verticies[i]->visited = false;
        verticies[i]->distance = 0;
    }

    for(int i = 0; i < size; i++) {
        if(verticies[i]->key == keyStart) {
            vStart = verticies[i];
        }
        if(verticies[i]->key == searchKey) {
            vDest = verticies[i];
        }
    }

    vector<vertex*> solvedList;
    solvedList.push(vStart);

    vStart->visited = true;

    while(solvedList.size()) {
        pop = Q.front();
        Q.pop();
        if(!pop->visited) {
            pop->visited = true;
        }
        size = pop->adj.size();
        for(int i = 0; i < size; i++) {
            if(!pop->adj[i].v->visited) {
                Q.push(pop->adj[i].v);
                pop->adj[i].v->previous = pop;
                pop->adj[i].v->distance = pop->distance+1;
            }
        }
        if(pop == vDest){
            break;
        }
    }
    if(!vDest->visited){
        std::cout << "No path from start to end" << std::endl;
    }

    vertex* crawler = pop;
    while(crawler) {
        crawler = crawler->previous;
    }
}
#+end_src
