#+title: Heap

#+NAME: type
#+begin_src :exports none
std::string
#+end_src

* Table of Contents :toc:
- [[#heap-properties][Heap Properties]]
- [[#heap-declaration][Heap Declaration]]
  - [[#min-heap][Min Heap]]
- [[#heap-definition][Heap Definition]]
  - [[#min-heap-1][Min Heap]]

* Heap Properties
Like a BST but unorganized left to right just up and down, why it's called binary heap

Rules:
- Parent is either greater than or less than it's children
- The Maximum Differemce between the longest and shortest branch in the heap from root is one

Variations:
- Min Heap: Root is smallest node
- Max Heap: Root is largest node

Applications/Examples:
- Sorting Algorithm
- Priority Queue
- Dijkstra's Priority Queue (Has O(e^log(e)) complexity)
* Heap Declaration
** Min Heap
Here is the Declaration of a Min Heap (a Max Heap is incredibly similar so notes will not go into Max Heap)
#+NAME: Min Heap Declaration
#+begin_src cpp :exports code :noweb strip-export :tangle minheap.hpp
#ifndef MINHEAP_H_
#define MINHEAP_H_
#include<iostream>
#include<string>

class MinHeap {
    public:
        MinHeap(int cap);
        ~MinHeap();
        void push(<<type>> k);
        int pop();
        int peek();
        void printHeap();
    private:
        int *heap;
        int capacity;
        int currentSize;
        void MinHeapify(int index);
        int parent(int i);
        int right(int i);
        int left(int i);
};
#+end_src
* Heap Definition
** Min Heap
*** Public
- ~MinHeap(int capacity)~ -> Class Constructor
#+NAME: Constructor
#+begin_src cpp :exports code
MinHeap::MinHeap(int cap) {
    currentSize = 0;
    capacity = cap;
    heap = new <<type>>[capacity];
}
#+end_src
- ~~MinHeap()~ -> Class Deconstructor
#+NAME: Deconstructor
#+begin_src cpp :exports code
MinHeap::~MinHeap(){

    delete [] heap;
}
#+end_src
- ~void push(<<type>> k)~ -> pushes ~<<type>>~ data ~k~ into heap
#+NAME: Heap Push
#+begin_src cpp :exports code
void MinHeap::push(<<type>> k){
    if (currentSize < capacity) {
        <<type>> temp;
        heap[currentSize] = k;
        i = currentSize;
        while(i != 0 && heap[parent(i)]  > heap[i]){
            temp = heap[i];
            heap[i] = heap[parent(i)];
            heap[parent(i)] = temp;
            i = parent(i);
        }

    } else {
        return;
    }
}
#+end_src
- ~void pop()~ -> pops the data from the heap
#+NAME: Heap Pop
#+begin_src cpp :exports code
<<type>> MinHeap::pop(){
    if (currentSize == 1) {
        currentSize = 0;
        return heap[0];
    } else if (currentSize > 1) {
        <<type>> poppedVal = heap[0];
        heap[0] = heap[currentSize - 1];
        currentSize--;
        MinHeapify(0);
        return poppedVal;
    } else {
        return;
    }
}
#+end_src
- ~int peek()~ -> returns the root of heap
#+NAME: Heap Peek
#+begin_src cpp :exports code
void MinHeap::peek() {
    return heap[1];
}
#+end_src
- ~void printHeap()~ -> prints the heap data this is just a linear print
#+NAME: Heap Print
#+begin_src cpp :exports code
void MinHeap::printHeap() {
    for(int i = 0; i < currentSize; i++) {
        std::cout << heap[i] << " ";
    }
}
#+end_src
*** Private
- ~int *heap~ -> points to the heap array
- ~int capacity~ -> stores the max capacity of heap
- ~int currentSize~ -> stores number of Elements in heap
- ~void MinHeapify(int index)~ -> recusively heapifies array (NEEDS TESTING, FOR CASE WHERE SUBTREES AREN'T HEAPIFIED)
#+NAME: Heapify
#+begin_src cpp :exports code
void MinHeap::MinHeapify(int i) {
    MinHeapify(left(i));
    MinHeapify(right(i));
    if(i > currentSize - 1) {
        return;
    }
    int leftChild = left(i);
    int righthild = right(i);

    int smallest = i;

    if (heap[leftChild] < heap[i]) {
        smallest = leftChild;
    }

    if (heap[rightChild] < heap[smallest]) {
        MinHeapifty(smallest);
    }
}
#+end_src
- ~int parent(int i)~ -> returns the parent of the element at index ~i~
#+NAME: Parent Heap
#+begin_src cpp :exports code
int MinHeap::parent(int i){
    return (i-1)/2;
}
#+end_src
- ~int left(int i)~ -> returns the parent of the element at index ~i~
#+NAME: Left Heap
#+begin_src cpp :exports code
int MinHeap::left(int i){
    return (2*i+1);
}
#+end_src
- ~int right(int i)~ -> returns the parent of the element at index ~i~
#+NAME: Right Heap
#+begin_src cpp :exports code
int MinHeap::right(int i){
    return (2*i+2);
}
#+end_src

#+NAME: Min Heap Definition
#+begin_src cpp :exports code :noweb strip-export :results code :tangle minheap.cpp
#include "minheap.hpp"

<<Constructor>>

<<Deconstructor>>

<<Heap Push>>

<<Heap Pop>>

<<Heap Peek>>

<<Heap Print>>

<<Heapify>>

<<Parent Heap>>

<<Left Heap>>

<<Right Heap>>
#+end_src
